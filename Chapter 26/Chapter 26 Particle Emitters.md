# Chapter 26: Particle Emitters

模拟的火热爆炸，驾驶雨水和呛人的烟雾使我们在大屏幕上行动起来。 在本章中，您将成为一个单人特效团队，因为您将自己的效果带到“小屏幕”，并学习如何使用粒子发射器创建自己的特效。

瀑布，火灾，烟雾和雨水效应都涉及大量的视觉项目 - 粒子 - 它们具有共同的物理特征，但仍然可能具有自己独特的大小，方向，旋转和轨迹。

粒子可以很好地创建逼真的效果，因为每个粒子都可以是随机的和不可预测的，就像物体本质上一样。 例如，雷暴中的每个雨滴可能具有独特的大小，形状和速度。

以下是粒子发射器可以实现的视觉效果的几个示例：



[图片]



您将重新阅读本书中的早期项目之一--Bahama Air航班信息 - 并使用粒子发射器重新创建第4章“在实践中查看动画”中的雪效果。

您将学习粒子系统如何在您尝试不同的发射器属性时工作，并观察它们对结果动画的影响。

当你完成时，你会看到你的粒子发射器雪效果后戴上你的帽子和手套，如下所示：



[图片]



这一章会很有趣; 请继续阅读！

## 创建发射器层
虽然在本书的这一点上你已经介绍了许多动画主题，但是还有一个用于创建动画的图层类，你还没有看到过：CAEmitterLayer。 您可以使用此类在Core Animation中本机创建粒子效果。

> 注意：有许多用于创建粒子效果的第三方类，但它们通常的目标是与游戏框架集成。 对于UIKit应用程序中的粒子动画，CAEmitterLayer是一个很好的选择，因为它内置并且易于使用。

打开入门项目并运行应用程序以查看您开始使用的内容：



[图片]



你的伦敦 - 巴黎航班信息屏幕背景阴暗。 此版本屏幕上的航班信息不会改变; 这样，你可以专注于雪效果。

打开ViewController.swift并将以下代码添加到viewDidLoad（）的底部：

```swift
let rect = CGRect(x: 0.0, y: 100.0,
  width: view.bounds.width, height: 50.0)
let emitter = CAEmitterLayer()
emitter.frame = rect
view.layer.addSublayer(emitter)
```

此代码创建一个新的CAEmitterLayer，将图层的框架设置为占据屏幕的整个宽度，并将图层定位在屏幕顶部附近。

接下来，您需要设置要与粒子效果一起使用的发射器类型。

将以下代码添加到viewDidLoad（）：

```swift
emitter.emitterShape = .rectangle
```

发射器的形状通常会影响创建新粒子的区域，但在您创建类似3D的粒子系统的情况下，它也会影响它们的z位置。

以下是三种最简单的发射器形状：

#### 点形状
kCAEmitterLayerPoint的发射器形状导致在同一点创建所有粒子：发射器的位置。 对于涉及火花或烟火的效果，这是一个不错的选择。



[图片]



例如，您可以通过在同一点创建所有粒子并使它们在消失前沿不同方向飞行来创建火花效果。

#### 线形
kCAEmitterLayerLine的发射器形状沿发射器框架的顶部创建所有粒子。

这是一种用于瀑布效果的发射器形状; 水粒子出现在瀑布的顶部边缘并像这样级联：



[图片]



#### 矩形形状
最后，kCAEmitterLayerRectangle的发射器形状通过给定的矩形区域随机创建粒子：



[图片]



这种发射器形状非常适合许多不同的效果，包括碳酸饮料和爆米花中的气泡。

由于雪从整个天空中随机出现，矩形发射器形状是您项目的不错选择。

> 注意：还有一些发射器形状 - 长方体，圆形和球形 - 但这些超出了本章的范围。 有关详细信息，请查看Apple文档中的CAEmitterLayer类参考。

### 添加发射器帧
将以下代码添加到viewDidLoad（）的末尾：

```swift
emitter.emitterPosition = CGPoint(x: rect.width/2,
  y: rect.height/2)
emitter.emitterSize = rect.size
```

结合形状，位置和尺寸属性定义发射器框架。 在这里，您可以将发射器的位置设置为图层的中心，并将发射器大小设置为等于图层的大小。

这意味着发射器占用整个图层帧，如下所示：



[图片]



### 创建发射器单元
现在您已配置了发射器的位置和大小，您可以继续添加发射器单元。

发射器单元是表示一个粒子源的数据模型。 它与CAEmitterLayer是一个单独的类，因为单个发射器层可以包含一个或多个单元。

例如，在爆米花动画中，你可以有三个不同的单元格来表示爆米花内核的不同状态：完全弹出，半弹出和那些顽固的未爆炸内核：



[图片]



在本章中，您将只使用一个发射器单元; 您将有机会在本教程的挑战部分中使用多个单元格。

将以下代码添加到viewDidLoad（）的底部：

```swift
let emitterCell = CAEmitterCell()
emitterCell.contents = UIImage(named: "flake.png")?.cgImage
```

在上面的代码中，您创建一个新单元格并将flake.png设置为其内容。 contents属性包含将从中创建新粒子的模板。

下面是深色背景上放大的flake.png屏幕截图：



[图片]



您的发射器将创建此图像的多个不同副本以模仿真实的雪花。

将以下代码添加到viewDidLoad（）的底部：

```swift
emitterCell.birthRate = 20
emitterCell.lifetime = 3.5
emitter.emitterCells = [emitterCell]
```

上面的代码指示您的单元格每秒创建20个雪花并将它们保留在屏幕上3.5秒。 这意味着在任何给定时间屏幕上将有70个雪花，除了动画的最初几秒之前，最旧的粒子开始消失。

最后，使用所有发射器单元的数组设置emitterCells属性。 请记住，您可以拥有多个发射器单元，但是您从一个发射器单元开始，因此该数组具有单个值。 一旦设置了发射器单元列表，发射器就会开始创建粒子。

构建并运行您的应用程序; 看看你到目前为止的伪雪花效果：



[图片]



flake.png的多个副本在3.5秒后显示并消失。 然而，雪是奇怪的静态 - 它不会落在任何地方。 您是否有开发印章将其变成可信的雪景？

大！ 是时候研究一些CAEmitterCell的属性了。

## 控制你的粒子
在这一章中，雪粒出现，在太空中漂浮几秒钟，然后消失。 那令人难以置信的无聊 - 即使对于寿命为3.5秒的粒子！ 你的下一个任务是让这些漫无目的的粒子在他们的生活中有一些方向。

### 改变粒子方向
将以下代码添加到viewDidLoad（）的底部：

```swift
emitterCell.yAcceleration = 70.0
```

这将在y方向上增加一点加速度，因此粒子会像真雪一样向下漂移。

构建并运行项目以查看效果：



[图片]



这看起来有点像雪 - 但雪很少直接下降。 要解决此问题，请向粒子添加以下水平加速度：

```swift
emitterCell.xAcceleration = 10.0
```

再次构建和运行您的项目; 雪花应该向下对角线方向移动。



[图片]



为了产生温和的坠落效果，你将直接射击粒子并让yAcceleration将它们拉下来。 添加以下代码：

```swift
emitterCell.velocity = 20.0
emitterCell.emissionLongitude = .pi * -0.5
```

发射经度是粒子的初始角度，速度参数设置粒子的初始速度，如下所示：



[图片]



再次构建并运行项目以查看结果：



[图片]



每次更改时，您的动画效果会越来越好。 但这些粒子看起来像雪花大小的杀戮机器人一致地机械移动。 这是因为每个粒子具有完全相同的初始角度，速度和加速度。 您需要为粒子创建过程添加一些随机性。

### 为粒子添加随机性
将以下代码添加到viewDidLoad（）：

```swift
emitterCell.velocityRange = 200.0
```

这告诉发射器应该是随机值范围。 由于粒子动画的随机范围在本章中经常使用，因此值得花一点时间来解释它们是如何工作的。

所有粒子的初始速度都相同，为20; 添加速度范围为每个粒子分配随机速度，如下所示：



[图片]



每个粒子的速度将是（20-200）= -180和（20 + 200）= 220之间的随机值。具有负初始速度的粒子根本不会飞起来; 一旦它们出现在屏幕上，它们就会开始飘落。 具有正速度的粒子将首先飞起，然后向下漂浮。

构建并运行您的项目以查看您所做的更改：



[图片]



好吧，事情肯定是随机的：有些雪花跳得和屏幕的上边缘一样高，而有些雪花出现，徘徊片刻，然后摔倒。 最初的粒子方向是下一个随机化的方向。

将以下代码添加到viewDidLoad（）：

```swift
emitterCell.emissionRange = .pi * 0.5
```

最初，您将所有粒子配置为在它们出现时直接向上（以-π/ 2角度）拍摄。 上面的代码行指示发射器为（-π/ 2  - π/ 2）= 180度和（-π/ 2 +π/ 2）= 0度范围内的每个粒子挑选一个随机角度，如下图所示：



[图片]



粒子将以不同的角度从x轴向上移动而不是直线向上移动。

再次运行项目以查看动画的更改方式：



[图片]



现在这是随机的！ 你的虚拟暴风雪真的变得生机勃勃。

### 改变粒子颜色
CAEmitterLayer的一个便利功能是能够为粒子设置色调。 例如，您可以将雪花淡蓝色而不是鲜明的白色，因为蓝色通常与雨，水，雪或冰有关。

将以下代码添加到viewDidLoad（）的底部：

```swift
emitterCell.color = UIColor(red: 0.9, green: 1.0, blue: 1.0, alpha: 1.0).cgColor
```

构建并运行项目以查看对粒子的色调效果：



[图片]



这种变化看起来很有趣，但所有的雪花都是蓝色的统一色调。 如果你可以随机化每个雪花的颜色，这不是很好吗？

您可以！ 您需要做的就是为粒子颜色定义三个独立的范围：红色，绿色和蓝色组件各一个。

将以下代码添加到viewDidLoad（）的末尾：

```swift
emitterCell.redRange   = 0.3
emitterCell.greenRange = 0.3
emitterCell.blueRange  = 0.3
```

此代码为每个颜色值定义以下范围：



[图片]



绿色和蓝色分量值现在是0.7到1.3之间的随机值; 但是，高于1.0的值的上限为1.0，因此有效范围为0.7到1.0。 红色成分的上限介于0.6和1.0之间，因为其“正常”值为0.9。 这些是相对较窄的范围，因此产生的随机颜色仍然很轻。

构建并运行项目以查看雪花染色工作的结果：



[图片]



嗯，这是随机的。 它只是我，还是看起来正在下雨糖果洒？

您可以尝试各个颜色组件上的各种范围，以根据需要将颜色偏向特定色调。 目前，只需使用以下内容替换上面添加的代码：

```swift
emitterCell.redRange   = 0.1
emitterCell.greenRange = 0.1
emitterCell.blueRange  = 0.1
```

构建并运行以查看更微妙的颜色变化：



[图片]



### 随机化粒子外观
即使在您添加了所有自定义之后，雪花仍然看起来相对均匀。 在本章的这一部分中，您将使每个粒子都成为一个美丽而独特的雪花 - 首先为每个雪花指定一个随机大小。

将以下代码添加到viewDidLoad（）：

```swift
emitterCell.scale = 0.8
emitterCell.scaleRange = 0.8
```

在这里，您将基本粒子大小设置为原始大小的80％，然后为随机大小指定一个宽范围：



[图片]



这样可以产生1.6倍原始尺寸的蓬松雪花，一直到零尺寸的微小薄片，一旦你创造出来就会消失。

构建并运行项目以查看新的雪花大小。



[图片]



您不仅可以设置雪花的初始大小，还可以在雪花落下时修改雪花的大小。 也许它在温暖的雾气中融化，因为它接近地面？

将以下行添加到viewDidLoad（）：

```swift
emitterCell.scaleSpeed = -0.15
```

上面的scaleSpeed属性指示粒子按比例缩小每秒原始大小的15％。

大粒子在从视线中消失之前会大幅收缩，而小粒子会在它们生命结束前完全消失。 不要心疼，这只是生活的雪花圈。

构建并运行您的项目，看看你的雪花在落下时如何融化：



[图片]



当雪花接近屏幕的下半部分时，雪花会越来越小。 这是一个很好的效果 - 但现在屏幕的下半部分看起来有点空洞。 我发烧了，唯一的处方是...更多的雪花！

找到您设置emitterCell.birthRate的行，并将值替换为150，如下所示：

```swift
emitterCell.birthRate = 150
```

构建并运行以查看您的暴风雪形成：



[图片]



每次迭代都会让你的动画变得越来越好，但它仍然看起来有些平淡。

您可以通过随机化每个雪花的alpha值为场景添加大量深度。

将以下内容添加到viewDidLoad（）的底部：

```swift
emitterCell.alphaRange = 0.75
emitterCell.alphaSpeed = -0.15
```

您设置了一个宽的alpha范围，从0.25到1.0的上限值。 alphaSpeed与scaleSpeed非常相似，可以随时间更改粒子的alpha值。

再次构建并运行您的项目，以查看简单的alpha动画为您的降雪带来的深度效果：



[图片]



您已经涵盖了CAEmitterCell提供的大部分内容; 本章的其余部分是关于为动画添加润色。

## 添加一些最终的抛光
在viewDidLoad（）中找到设置emissionLongitude并将其更改为以下内容的行：

```swift
emitterCell.emissionLongitude = -.pi
```

请记住，发射经度是粒子的起始角度。 这种变化会让雪花旋转一下，好像被风推开一样。

接下来，在viewDidLoad（）中找到声明rect的行并按如下方式修改它：

```swift
let rect = CGRect(x: 0.0, y: -70.0, width: view.bounds.width, height: 50.0)
```

这会将发射器移出屏幕，因此用户无法看到粒子来自何处。

最后，将以下位代码添加到viewDidLoad（）以随机化雪花在屏幕上保留的时间长度：

```swift
emitterCell.lifetimeRange = 1.0
```

这会将每个雪花的生命周期设置为2.5到4.5秒之间的随机值。

构建并运行应用程序以查看这些最终的抛光位。

虽然本章对雪效应非常重视，但每个概念都完全适用于其他粒子系统。 到目前为止，我见过的每个粒子实现都以类似的方式工作。 您始终拥有一组要为每个粒子配置的功能，并且发射器会在系统创建大量原始粒子副本时随机化系统。

如果您完成了本章，那么您就可以开始探索任何粒子系统，无论是在SpriteKit，Unity还是任何其他自定义粒子发射器类中。

一旦了解了粒子系统的工作原理，设计和实现粒子效果就会非常有趣！ 为此，您可以通过以下挑战来定制降雪效果。

## 关键点
* 粒子发射器允许您创建复杂的动画效果，通常包含大量小精灵（或粒子）。
* 粒子效果适用于源自现实生活的许多效果，如烟雾，瀑布，雨或雪。
* 要创建粒子动画，您需要再创建一个CAEmitterCell实例，配置其发射率，粒子寿命和其他属性，最后将单元格添加到屏幕上的CAEmitterLayer。

## 挑战
### 挑战：向发射器层添加更多单元
这一挑战比大多数人更自由;您的任务是将一个或多个单元格添加到刚刚开发的发射器中。初学者项目包括许多可供挑选单元格选择的雪花：flake1.png，flake2.png，flake3.png和flake4.png。

在向发射器添加更多单元格之前，请考虑屏幕上过度拥挤的影响。一个现有的细胞每秒发出150个雪花，导致密集的降雪。如果向发射器中再添加两个单元，则需要将每个发射器每秒减少约50个粒子，以保持系统中大致相同的雪花密度。

玩弄每个细胞的特性：使一些薄片旋转，而其他细胞迅速落到地面。雪花形状flake2.png不是对称的，所以试着设置它的细胞旋转和spinRange属性，使这些粒子像被风吹动一样旋转。

与之前的章节一样，如果动画在模拟器中变得不稳定，请在设备上测试黄油效果。对这一挑战没有正确或错误的解决方案;当你满意时，只需停止播放效果。我已经在本章中介绍了我最喜欢的解决方案之一，一旦完成更改粒子系统，您可以查看：



[图片]



在白雪皑皑的季节的精神，下一章展示了一些完全欣赏你的降雪效果的生物：企鹅！

